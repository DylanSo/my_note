---
title: 大话数据结构笔记
date: 2021-04-21 15:36:27
categories: 学习笔记
tags: 数据结构与算法
---

## 第一章：数据结构绪论

**数据：**描述客观事物的符号，能被计算机识别、操作、处理的符号集合

**数据对象：**性质相同的数据元素集合，是数据的子集

**数据元素(记录)：**有意义的基本单位(人类->人)

**数据项：**最小单位，比数据元素小(耳朵)

**数据结构：**相互之间存在一种或多种特定关系的数据元素合集

### 逻辑结构

集合结构(~)，线性结构(1-1)，树形结构(1-n)，图形结构(n-m)

结点，关系(无/有箭头)

### 物理结构

顺序储存结构，链式储存结构(连续/不连续)

### 数据类型

原子类型(不可分解)，结构类型(原子组合)，抽象类型

## 第二章：算法

**算法是解决特定问题求解步骤的描述**

### 算法的特性

输入，输出，有穷性，确定性(二义性)，可行性

### 算法设计的要求

正确性，可读性，健壮性，高效性，存储量低

### 算法效率的度量方法

事后统计法，事前分析估算法

规模n无限制，总有一个数值N标定两个算法的效率平衡(渐进增长)

n>N时，总有f(n)>g(n)，则f(n)渐进增长快于g(n)

主要看最高阶项的阶数

### 算法时间复杂度

T(n)=O(f(n))，随着n的增大，T(n)增长最慢的算法为最优算法

O(1)常数阶

O(n)线性阶

O(n^2)平方阶

...

> 推导大O阶：
>
> - ​	用常数1取代运行时间中的所有加法常数
> - 在修改后的运行次数函数中，只保留最高阶项
> - 若最高阶项存在且不是1，则去除与这个项相乘的常数

分支结构：常数阶

循环结构：线性阶

*结构：对数阶

循环嵌套：平方阶

常数阶<对数阶<线性阶<nlogn阶<平方阶<立方阶<指数阶<阶乘阶<n^n阶

**最坏情况与平均情况**

### 算法空间复杂度

S(n)=O(f(n))

O(1)原地工作

## 第三章：线性表

### **线性表：**零个或多个数据元素的有限序列

每个元素有一个前驱和一个后继，第一个和最后一个除外

元素个数n为线性表长度，特殊的，n=0时称为空表

在较复杂的线性表中，一个数据元素可以由若干个数据项组成(如表格)

操作：重置，查存，索引，插入元素，删除元素，获得长度

### **顺序存储结构**

```c
#define MAXSIZE 20
typedef int ElemType;
typedef struct{
	ElemType data[MAXSIZE];
	int length;
}SqList;
```

获取元素：

```c
int GetElem(SqList L,int i,ElemType *e) {
	if (L.length == 0 || i<1 || i>L.length) {
		return false;//Out of edge
	}
	*e = L.data[i - 1];
	return true;
}
```

插入元素：

```c
int ListInsert(SqList *L, int i, ElemType *e) {
	int k;
	if (L->length == MAXSIZE) {//Full list
		return false;
	}
	if (i < 1 || i > L->length + 1) {//Out of edge
		return false;
	}
	if (i <= L->length) {//Isn't at the end of the list
		for (k = L->length - 1; k >= i - 1; k--) {
			L->data[k + 1] = L->data[k];//Move each elems position behind
		}
	}
	L->data[i - 1] = *e;//At the end of the list
	L->length++;
	return true;
}
```

删除元素：

```c
int ListDelete(SqList *L,int i,ElemType *e) {
	int k;
	if (L->length == 0) {//List is empty
		return false;
	}
	if (i<1 || i>L->length) {//Out of edge
		return false;
	}
	*e = L->data[i - 1];
	if (i < L->length) {//Isn't at the end of the list
		for (k = i; k < L->length; k++) {
			L->data[k - 1] = L->data[k];//Move each elems position behind
		}
	}
	L->length--;
	return true;
}
```

删除和插入操作算法着重多练(最坏时间复杂度O(n))

**优点：**淡化逻辑关系，快速存取表中任意元素

**缺点：**插入和删除开销大，表长变化大时难以确定存储空间大小，不能精确利用内存

### **链式存储结构**



**存储映像(结点Node)**

- 数据域：储存数据元素本身

- 指针域：储存直接后继的位置(指针/链)

只包含一个指针域：单链表

第一个结点的存储位置：由头指针指向

最后一个结点的指针域：存放空指针(NULL)

在第一个结点前可附加“头结点”，可存放长度等附加信息

**单链表的操作：**

- 读取：遍历，最坏时间复杂度O(n)

```c
int GetElem(LinkList L,int i,ElemType *e) {
	int j;
	LinkList p;
	p = L->next;
	j = 1;//Counter
	while (p && j < i) {//Find node i-1
		p = p->next;
		j++;
	}
	if (!p || j > i) {//Think about why have j > i
		return false;//Node i isn't exist
	}
	*e = p->data;
	return true;
}
```

- 插入：指针指向后继，前一元素指针指向自己，最坏时间复杂度O(n)

```c
int ListInsert(LinkList *L,int i,ElemType *e) {
	int j;
	LinkList p,s;
	p = *L;
	j = 1;
	while (p && j < i) {//Find node i-1
		p = p->next;
		j++;
	}
	if (!p || j > i) {//Think about why have j > i
		return false;//Node i isn't exist
	}
	s = (LinkList)malloc(sizeof(Node));//Insert
	s->data = *e;//Pay attention to the order
	s->next = p->next;
	p->next = s;
	return true;
}
```

- 删除：释放自身，前驱指针直接指向后继，最坏时间复杂度O(n)

```c
int DeleteElem(LinkList *L,int i,ElemType *e) {
	int j;
	j = 1;
	LinkList p,tem;
	p = *L;
	while (p && j < i) {//Find node i-1
		p = p->next;
		j++;
	}
	if (!p || j > i) {//Think about why have j > i
		return false;//Node i isn't exist
	}
	tem = p->next;//Delete and return the data
	p->next = tem->next;
	*e = tem->data;
	free(tem);
	return true;
}
```

- 整表创建：创建表头->头插法/尾插法

```c
int CreateListHead(LinkList *L, int n) {
	LinkList p;
	int i;
	srand(time(0));
	*L = (LinkList)malloc(sizeof(Node));
	(*L)->next = NULL;
	for (i = 0; i < n; i++) {
		p = (LinkList)malloc(sizeof(Node));
		p->data = rand() % 100 + 1;
		p->next = (*L)->next;
		(*L)->next = p;
	}
}
```

```c
void CreateListTail(LinkList *L, int n) {
	LinkList p,s;
	int i;
	srand(time(0));
	*L = (LinkList)malloc(sizeof(Node));
	s = *L;
	for (i = 0; i < n; i++) {
		p = (LinkList)malloc(sizeof(Node));
		p->data = rand() % 100 + 1;
		s->next = p;
		s = p;
	}
	p->next = NULL;
}
```

- 整表删除：从头逐个释放

```c
int ClearList(LinkList *L) {
	LinkList p,q;
	p = (*L)->next;
	while (p) {
		q = p->next;
		free(p);
		p = q;
	}
	(*L) = NULL;
	return true;
}
```

**优点：**插入、删除越频繁，效率优势越明显

**缺点：**读取是劣势

#### 静态链表

data、cur(Cursor游标、相当于指针,为0时表示无指向)

不提供结构体的语言，可用两个并行数组来实现

使用较大数组，下标作为地址

备用链表：未被使用的数组元素

**静态链表的操作：**

- 插入：先将要插入的元素排在最后，后面与单链表类似
- 删除：类似

**优点：**相对于顺序存储结构，插入和删除时不需要移动大量元素

**缺点：**还是没有解决表长难以确定的问题，无随机存取的特性

#### 循环链表(circular linked list)

首尾相连的单链表，尾指针->头指针

合并链表

```c
p = rearA -> next;
rearA -> next = rearB -> next -> next;
q = rearB -> next;
rearB -> next = p;
free(q);
```

#### 双向链表(double linked list)

每个数据元素的指针域添加指向直接前驱的指针，链表首尾相连

插入：

```c
p -> prior = p;
s -> next = p -> next;
p -> next -> prior = s;
p -> next = s;
```

删除：

```c
p -> prior -> next = p -> next;
p -> next -> prior = p -> prior;
free(p);
```

## 第四章：栈与队列